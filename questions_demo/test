知识体系：
跳槽时时刻刻都在发生，但是我建议大家跳槽之前，先想清楚为什么要跳槽。切不可跟风，看到同事一个个都走了，自己也盲目的面试起来（期间也没有准备充分），到底是因为技术原因（影响自己的发展，偏移自己规划的轨迹），还是钱给少了，不受重视。
准备不充分的面试，完全是浪费时间，更是对自己的不负责（如果title很高，当我没说）。
今天给大家分享下chenssy在这次跳槽中整理的Java面试大纲，其中大部分都是面试过程中的面试题，可以对照这查漏补缺，当然了，这里所列的肯定不可能覆盖全部方式。
项目介绍 大部分情况，这是一场面试的开门题，面试官问这个问题，主要是考察你的概述能力和全局视野。有的人经常抱怨自己每天在堆业务，但没有成长。事实上，很多情况下确实在堆业务，但并不是没有成长的。并非做中间件或者技术架构才是成长，例如我们的需求分析能力，沟通协作能力，产品思维能力，抽象建模能力等都是一个非常重要的硬实力。
好的，现在进入正文。
1、明确项目是做什么的 
2、明确项目的价值。（为什么做这个项目，它解决了用户什么痛点，它带来什么价值？）
3、明确项目的功能。（这个项目涉及哪些功能？） 
4、明确项目的技术。（这个项目用到哪些技术？）
5、明确个人在项目中的位置和作用。（你在这个项目的承担角色？）
6、明确项目的整体架构。 
7、明确项目的优缺点,如果重新设计你会如何设计。 
8、明确项目的亮点。（这个项目有什么亮点？） 
9、明确技术成长。（你通过这个项目有哪些技术成长？）



设计模式
    策略模式  对应spring ioc
    常见设计模式


安全&性能安全问题
安全要素与 STRIDE 威胁
防范常见的 Web 攻击
服务端通信安全攻防
HTTPS 原理剖析
HTTPS 降级攻击
授权与认证
基于角色的访问控制
基于数据的访问控制
性能优化
性能指标有哪些
如何发现性能瓶颈
性能调优的常见手段
说说你在项目中如何进行性能调优
工程篇需求分析
你如何对需求原型进行理解和拆分
说说你对功能性需求的理解
说说你对非功能性需求的理解
你针对产品提出哪些交互和改进意见
你如何理解用户痛点
设计能力
说说你在项目中使用过的 UML 图
你如何考虑组件化
你如何考虑服务化
你如何进行领域建模
你如何划分领域边界
说说你项目中的领域建模
说说概要设计
设计模式
你项目中有使用哪些设计模式
说说常用开源框架中设计模式使用分析
说说你对设计原则的理解
23种设计模式的设计理念
设计模式之间的异同，例如策略模式与状态模式的区别
设计模式之间的结合，例如策略模式+简单工厂模式的实践
设计模式的性能，例如单例模式哪种性能更好。
业务工程
你系统中的前后端分离是如何做的
说说你的开发流程
你和团队是如何沟通的
你如何进行代码评审
说说你对技术与业务的理解
说说你在项目中经常遇到的 Exception
说说你在项目中遇到感觉最难Bug，怎么解决的
说说你在项目中遇到印象最深困难，怎么解决的
你觉得你们项目还有哪些不足的地方
你是否遇到过 CPU 100% ，如何排查与解决
你是否遇到过 内存 OOM ，如何排查与解决
说说你对敏捷开发的实践
说说你对开发运维的实践
介绍下工作中的一个对自己最有价值的项目，以及在这个过程中的角色
软实力
说说你的亮点
说说你最近在看什么书
说说你觉得最有意义的技术书籍
工作之余做什么事情
说说个人发展方向方面的思考
说说你认为的服务端开发工程师应该具备哪些能力
说说你认为的架构师是什么样的，架构师主要做什么
说说你所理解的技术专家



技术题目
重点：

2018年5月16号：
工作多少年了，还在传统公司写if / for 等简单的代码？那你就真的要被社会淘汰了，工作多年其实你与初级工程师又有多少区别呢？那么作为一个高级Java攻城狮需要突破哪些知识点呢？
1、Java基础技术体系、JVM内存分配、垃圾回收、类装载机制、性能优化、反射机制、多线程、网络编程、常用数据结构和相关算法。
2、对面向对象的软件开发思想有清晰的认识、熟悉掌握常用的设计模式。
3、熟练掌握目前流行开源框架(spring/springmvc/ibatis)，并且对其核心思想、实现原理有一定认知。
4、熟悉Oracle、MySQL等数据库开发与设计以及缓存系统Redis或 Memcached的设计和研发。
5、熟悉底层中间件、分布式技术（包括缓存、消息系统、热部署）、消息中间件：ActiveMQ、RabbitMQ、工作流中间件:JBPM。
6、精通shell编程，熟练应用awk、sed、grep、strace、tcudump、gdb等常用命令。
7、有大型分布式、高并发、高负载（大数据量）、高可用性系统设计开发经验。
8、对配置管理和敏捷研发模式有所了解（svn,git）。
9、熟悉常见的一些解决方案及其原理：单点登录、分布式缓存、SOA、全文检索、消息中间件，负载均衡、连接池、流计算等。
10、能大概知道市面上主流技术的特点及业务瓶颈。


2018年5月15号：
下面总结10道面试腾讯的Java面试题。
1、说几种常见的攻击方式及预防手段。
2、http1.x和http2.x的区别。
3、mysql查询语句怎么做性能分析。
4、你知道哪几种排序算法？
5、HashMap和HashTable的区别，并说明其底层实现数据结构。
6、HashMap满了之后怎么扩容？
7、Linux中远程传输文件有什么方式？
8、说说Java中异常的分类。
9、TCP和UDP的区别，TCP为什么是三次握手，不是两次。
10、说说数据库设计的三范式，可以违反三范式吗？


2018年5月11号：
首先，某头条的文章量、用户量都是很大的，点击量那就更恐怖了！
请问，如果实时展现热门文章，比如近8小时点击量最大的文章前100名。如果是你来开发这个功能，你怎么做？
这个好办啊，Redis一个SortedSet搞定啊，Score计数，Key是文章ID，不就OK了么？
回答的不错，你可以走了！
要听清题目，说好的8小时动态时间窗口，计数是会过期的。还有，头条的量有这么小么，一个Redis就搞定了？同学啊，我告诉你，文章的量你起码得估计个几十万，用户你得估计几个亿，点击量你至少得估计个1M/s吧。


2018年3月9号：
1.http协议：GET  POST PUT 等； http1.1 keepalive  chunk  200 301  502等错误码  RFC协议每个字段在二进制码的含义。
2.redis延迟队列设计以及原理；
3.并发、JVM、分布式、TCP/IP协议这些个关键字

2018年3月8号：
1.StringBuilder 和“+”连接字符串的区别；StringBuilder源码其他方法； 为什么java的String要设计成immutable 和C++的可变字符串相比，二者优劣有什么区别。
2.数据结构、算法、编译原理、操作系统、架构设计、项目经验、框架、网络传输、后台或者前端、语言特性
3.线上OOM问题（java out of memory）


2018年2月11号：
Spring Boot  项目
Spring Cloud    ：Spring cloud最新的6Dubbo  ：稍微有点落后了
docker  k8s 微服务： 微服务治理


工作中比较难搞定：
     延迟队列，定时取消发送
     耗电量的平衡（最开始安卓发送心跳包），服务端主动连接客户端，包括确定心跳包时间，版本迭代nodejs 迭代为golang版本；自有通道，华为通道，小米通道；标签功能，以及二个通道包活，最总要的是不要同一个信息发送二份； 短信服务，
   前端页面vue 框架说明；
   spring boot   ioc（容器，直接使用） 以及aop（业务共性逻辑）
   netty  jvm 原理等
   golang语言学习，包括语言特性等特征；快慢队列；






题目解析以及题目具体分析：
以下面试题为个人在面试过程中所遇到的，仅供参考！如有错误，望指出。



1、servlet执行流程
客户端发出http请求，web服务器将请求转发到servlet容器，servlet容器解析url并根据web.xml找到相对应的servlet，并将request、response对象传递给找到的servlet，servlet根据request就可以知道是谁发出的请求，请求信息及其他信息，当servlet处理完业务逻辑后会将信息放入到response并响应到客户端。
2、springMVC的执行流程
springMVC是由dispatchservlet为核心的分层控制框架。首先客户端发出一个请求web服务器解析请求url并去匹配dispatchservlet的映射url，如果匹配上就将这个请求放入到dispatchservlet，dispatchservlet根据mapping映射配置去寻找相对应的handel，然后把处理权交给找到的handel，handel封装了处理业务逻辑的代码，当handel处理完后会返回一个逻辑视图modelandview给dispatchservlet，此时的modelandview是一个逻辑视图不是一个正式视图，所以dispatchservlet会通过viewresource视图资源去解析modelandview，然后将解析后的参数放到view中返回到客户端并展现。
3、给定一个txt文件，如何得到某字符串出现的次数
File file = new File("E://test.txt");
InputStream is = new FileInputStream(file);
byte b[] = new byte[1024];
int a = is.read(b);
String str[] = new String(b,0,a).split("");
int count = 0;
for(int i = 0;i<str.length;i++){
if("a".equals(str[i]))count++;
}
System.out.println(count);
4、Java设计模式思想（单列模式，工厂模式，策略模式，共23种设计模式）
a) 单例模式：单例模式核心只需要new一个实例对象的模式，比如数据库连接，在线人数等，一些网站上看到的在线人数统计就是通过单例模式实现的，把一个计时器存放在数据库或者内存中，当有人登陆的时候取出来加一再放回去，有人退出登陆的时候取出来减一再放回去，但是当有两个人同时登陆的时候，会同时取出计数器，同时加一，同时放回去，这样的话数据就会错误，所以需要一个全局变量的对象给全部人使用，只需要new出一个实例对象，这就是单例模式的应用，并且单例模式节省资源，因为它控制了实例对象的个数，并有利于gc回收。
b) 策略模式：就是将几个类中公共的方法提取到一个新的类中，从而使扩展更容易，保证代码的可移植性，可维护性强。比如有个需求是写鸭子对象，鸭子有叫，飞，外形这三种方法，如果每个鸭子类都写这三个方法会出现代码的冗余，这时候我们可以把鸭子中的叫，飞，外形这三个方法提取出来，放到鸭父类中，让每个鸭子都继承这个鸭父类，重写这三个方法，这样封装的代码可移植性强，当用户提出新的需求比如鸭子会游泳，那么对于我们oo程序员来讲就非常简单了我们只需要在鸭父类中加一个游泳的方法，让会游泳的鸭子重写游泳方法就可以了。
c) 工厂模式：简单的工厂模式主要是统一提供实例对象的引用，通过工厂模式接口获取实例对象的引用。比如一个登陆功能，后端有三个类，controller类，interface类，实现接口的实现类。当客户端发出一个请求，当请求传到controller类中时，controller获取接口的引用对象，而实现接口的实现类中封装好了登陆的业务逻辑代码。当你需要加一个注册需求的时候只需要在接口类中加一个注册方法，实现类中实现方法，controller获取接口的引用对象即可，不需要改动原来的代码，这种做法是的可拓展性强。
5、冒泡排序、二分查找
a) 冒泡
 public static void mp(int a[]) {

int swap = 0;
for (int i = 0; i < a.length; i++) {

for (int j = i; j < a.length; j++) {
if (a[j] > a[i]) {
swap = a[i];
a[i] = a[j];
a[j] = swap;
}
}
}

System.out.println(Arrays.toString(a));
}

b)二分查找public static int ef(int a[], int tag) {

int first = 0;
int end = a.length;
for (int i = 0; i < a.length; i++) {
int middle = (first + end) / 2;

if (tag == a[middle]) {
return middle;
}
if (tag > a[middle]) {
first = middle + 1;
}
if (tag < a[middle]) {
end = middle - 1;
}

}
return 0;
}
6、对ajax的理解
a) Ajax为异步请求，即局部刷新技术，在传统的页面中，用户需要点击按钮或者事件触发请求，到刷新页面，而异步技术为不需要点击即可触发事件，这样使得用户体验感增强，比如商城购物车的异步加载，当你点击商品时无需请求后台而直接动态修改参数。
9、父类与子类之间的调用顺序（打印结果）
a) 父类静态代码块
b) 子类静态代码块
c) 父类构造方法
d) 子类构造方法
e) 子类普通方法
f) 重写父类的方法，则打印重写后的方法
10、内部类与外部类的调用
a) 内部类可以直接调用外部类包括private的成员变量，使用外部类引用的this.关键字调用即可
b) 而外部类调用内部类需要建立内部类对象
11、多线程
a)一个进程是一个独立的运行环境，可以看做是一个程序，而线程可以看做是进程的一个任务，比如QQ是一个进程，而一个QQ窗口是一个线程。
b)在多线程程序中，多线程并发可以提高程序的效率，cpu不会因为某个线程等待资源而进入空闲状态，它会把资源让给其他的线程。
c)用户线程就是我们开发程序是创建的线程，而守护线程为系统线程，如JVM虚拟中的GC
d)线程的优先级别：每一个线程都有优先级别，有限级别高的可以先获取CPU资源使该线程从就绪状态转为运行状态。也可以自定义线程的有限级别
e)死锁：至少两个以上线程争取两个以上cpu资源，避免死锁就避免使用嵌套锁，只需要在他们需要同步的地方加锁和避免无限等待
12、AOP与IOC的概念（即spring的核心）
a) IOC：Spring是开源框架，使用框架可以使我们减少工作量，提高工作效率并且它是分层结构，即相对应的层处理对应的业务逻辑，减少代码的耦合度。而spring的核心是IOC控制反转和AOP面向切面编程。IOC控制反转主要强调的是程序之间的关系是由容器控制的，容器控制对象，控制了对外部资源的获取。而反转即为，在传统的编程中都是由我们创建对象获取依赖对象，而在IOC中是容器帮我们创建对象并注入依赖对象，正是容器帮我们查找和注入对象，对象是被获取，所以叫反转。
b) AOP：面向切面编程，主要是管理系统层的业务，比如日志，权限，事物等。AOP是将封装好的对象剖开，找出其中对多个对象产生影响的公共行为，并将其封装为一个可重用的模块，这个模块被命名为切面（aspect），切面将那些与业务逻辑无关，却被业务模块共同调用的逻辑提取并封装起来，减少了系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。
13、hibernate的核心思想
a) Hibernate的核心思想是ROM对象关系映射机制。它是将表与表之间的操作映射成对象与对象之间的操作。也就是从数据库中提取的信息会自动按照你设置的映射要求封装成特定的对象。所以hibernate就是通过将数据表实体类的映射，使得对对象的修改对应数据行的修改。
14、Struts1与Struts2的区别
15、最优删除谋字符串的某个字符
16、Arraylist与linkedlist的区别
a) 都是实现list接口的列表，arraylist是基于数组的数据结构，linkedlist是基于链表的数据结构，当获取特定元素时，ArrayList效率比较快，它通过数组下标即可获取，而linkedlist则需要移动指针。当存储元素与删除元素时linkedlist效率较快，只需要将指针移动指定位置增加或者删除即可，而arraylist需要移动数据。
17、mybaties与ibatise的区别
18、数据库优化
a) 选择合适的字段，比如邮箱字段可以设为char（6），尽量把字段设置为notnull，这样查询的时候数据库就不需要比较null值
b) 使用关联查询（ left join on）查询代替子查询
c) 使用union联合查询手动创建临时表
d) 开启事物，当数据库执行多条语句出现错误时，事物会回滚，可以维护数据库的完整性
e) 使用外键，事物可以维护数据的完整性但是它却不能保证数据的关联性，使用外键可以保证数据的关联性
f) 使用索引，索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快的多的速度检索特定的行，特别是对于max，min，order by查询时，效果更明显
g) 优化的查询语句，绝大多数情况下，使用索引可以提高查询的速度，但如果sql语句使用不恰当的话，索引无法发挥它的特性。
19、Tomcat服务器优化（内存，并发连接数，缓存）
a) 内存优化：主要是对Tomcat启动参数进行优化，我们可以在Tomcat启动脚本中修改它的最大内存数等等。
b) 线程数优化：Tomcat的并发连接参数，主要在Tomcat配置文件中server.xml中配置，比如修改最小空闲连接线程数，用于提高系统处理性能等等。
c) 优化缓存：打开压缩功能，修改参数，比如压缩的输出内容大小默认为2KB，可以适当的修改。
20、HTTP协议
a) 常用的请求方法有get、post
b) Get与post的区别：传送数据，get携带参数与访问地址传送，用户可以看见，这的话信息会不安全，导致信息泄露。而post则将字段与对应值封装在实体中传送，这个过程用户是不可见的。Get传递参数有限制，而post无限制。
21、TCP/UDP协议
22、Java集合类框架的基本接口有哪些
a) Collection集合接口，List、set实现Collection接口，arraylist、linkedlist，vector实现list接口，stack继承vector，Map接口，hashtable、hashmap实现map接口
23、类加载的过程
a) 遇到一个新的类时，首先会到方法区去找class文件，如果没有找到就会去硬盘中找class文件，找到后会返回，将class文件加载到方法区中，在类加载的时候，静态成员变量会被分配到方法区的静态区域，非静态成员变量1分配到非静态区域，然后开始给静态成员变量初始化，赋默认值，赋完默认值后，会根据静态成员变量书写的位置赋显示值，然后执行静态代码。当所有的静态代码执行完，类加载才算完成。
24、对象的创建
a) 遇到一个新类时，会进行类的加载，定位到class文件
b) 对所有静态成员变量初始化，静态代码块也会执行，而且只在类加载的时候执行一次
c) New 对象时，jvm会在堆中分配一个足够大的存储空间
d) 存储空间清空，为所有的变量赋默认值，所有的对象引用赋值为null
e) 根据书写的位置给字段一些初始化操作
f) 调用构造器方法（没有继承）
25、jvm的优化
a) 设置参数，设置jvm的最大内存数
b) 垃圾回收器的选择
26、高并发处理
a) 了解一点高并发性问题，比如一W人抢一张票时，如何保证票在没买走的情况下所有人都能看见这张票，显然是不能用同步机制，因为synchronize是锁同步一次只能一个人进行。这时候可以用到锁机制，采用乐观锁可以解决这个问题。乐观锁的简单意思是在不锁定表的情况下，利用业务的控制来解决并发问题，这样即保证数据的可读性，又保证保存数据的排他性，保证性能的同时解决了并发带来的脏读数据问题。
27、事物的理解
a) 事物具有原子性，一致性，持久性，隔离性
b) 原子性：是指在一个事物中，要么全部执行成功，要么全部失败回滚。
c) 一致性：事物执行之前和执行之后都处于一致性状态
d) 持久性：事物多数据的操作是永久性
e) 隔离性：当一个事物正在对数据进行操作时，另一个事物不可以对数据进行操作，也就是多个并发事物之间相互隔离。
28、Struts工作流程
a) 客户端发出一个请求到servlet容器
b) 请求经过一些列过滤被filterdispatcher调用，filterdispatch通过actionMapper去找相对应的action。
c) Actionmapper找到对应的action返回给filterdispatch，dispatch把处理权交给actionproxy
d) Actionproxy通过配置文件找到对应的action类
e) Actionproxy创建一个actionIinvocation的实例处理业务逻辑
f) 一旦action处理完毕，actioninvocation负责根据stuts.xml的配置找到对应的返回结果。返回结果通常是jsp页面。



最近有很多朋友去目前主流的大型互联网公司面试（阿里巴巴、京东、美团、滴滴），面试回来之后会发给我一些面试题。有些朋友轻松过关，拿到offer，但是有一些是来询问我答案的。
其实本来真的没打算写这篇文章，主要是自己得记忆力不是很好，不像一些记忆力强的人，面试完以后，几乎能把自己和面试官的对话都给记下来。自己当初面试完以后，除了记住一些聊过的知识点以外，具体的内容基本上忘得一干二净，所以写这篇文章其实是很有难度的。
但是，最近问我的人实在是太多了，为了避免重复回答，给自己省点力气，干脆就在这里统一回复了。说实话，我只能隐约想起并发、JVM、分布式、TCP/IP协议这些个关键字，具体的问题真的是几乎都没记住。而且就算我记住了，也告诉你了，你也背会了，但我觉得，在面试中，你被问到一模一样问题的可能性依然很小。甚至，就算你运气好被问到了，你也照着背下来了，也不一定就能对你的面试起到正面的作用，因为面试官万一多问一句，你可能就露馅了，那还不如干脆点说不会更好。在此给大家讲一下大型互联网企业面试题
我特意整理了一下，有很多问题不是靠几句话能讲清楚，所以干脆找朋友录制了一些视频，用来回答这些面试题。很多问题其实答案很简单，但是背后的思考和逻辑不简单，要做到知其然还要知其所以然。如果想学习Java工程化、高性能及分布式、高性能、深入浅出。性能调优、Spring，MyBatis，Netty源码分析的朋友可以加我的Java进阶群，675047716，群里有阿里大牛直播讲解技术，以及Java大型互联网技术的视频免费分享给大家。
先来看下自己记录的面试材料：
一、阿里巴巴面试
第一个：阿里面试都问什么？ ：（55分钟）
1、开发中Java用了比较多的数据结构有哪些？
2谈谈你对HashMap的理解，底层原理的基本实现，HashMap怎么解决碰撞问题的？
这些数据结构中是线程安全的吗？假如你回答HashMap是线程安全的，接着问你有没有线程安全的map，接下来问了conurren包。
3、对JVM熟不熟悉？简单说说类加载过程，里面执行的哪些操作?问了GC和内存管理，平时在tomect里面有没有进行过相关的配置
4、然后问了http协议，get和post的基本区别，接着tcp/ip协议，三次握手，窗口滑动机制。
5、开发中用了那些数据库？回答mysql，储存引擎有哪些？然后问了我悲观锁和乐观锁问题使用场景、分布式集群实现的原理。
6、然后问了我springmvc和mybatis的工作原理，有没有看过底层源码？
二、京东金融面试
1、Dubbo超时重试；Dubbo超时时间设置
2、如何保障请求执行顺序
3、分布式事物与分布式锁（扣款不要出现负数）
4、分布式session设置
5、执行某操作，前50次成功，第51次失败a全部回滚b前50次提交第51次抛异常，ab场景分别如何设置Spring（传播性）
6、Zookeeper有哪些用
7、JVM内存模型
8、数据库垂直和水平拆分
9、MyBatis如何分页；如何设置缓存；MySQL分页
10、熟悉IO么？与NIO的区别，阻塞与非阻塞的区别
11、分布式session一致性
12、分布式接口的幂等性设计「不能重复扣款」
三、美团面试
1、最近做的比较熟悉的项目是哪个？画一下项目技术架构图
2、JVM老年代和新生代的比例？
3、YGC和FGC发生的具体场景
4、jstack，jmap，jutil分别的意义？如何线上排查JVM的相关问题？
5、线程池的构造类的方法的5个参数的具体意义？
6、单机上一个线程池正在处理服务如果忽然断电该怎么办？（正在处理和阻塞队列里的请求怎么处理）？
7、使用无界阻塞队列会出现什么问题？
8、接口如何处理重复请求？
9、具体处理方案是什么？
10、如何保证共享变量修改时的原子性？
11、设计一个对外服务的接口实现类，在1,2,3这三个主机（对应不同IP）上实现负载均衡和顺序轮询机制（考虑并发）
四、滴滴面试
1、自我介绍，技术特点
2、兴趣是什么，优势是什么
3、jvm，jre以及jdk三者之间的关系？
4、Dubbo的底层原理，Zookeeper是什么
5、cincurrentMap的机制；TreeMap；Volatil关键字
6、快速排序；广度优先搜索（队列实现）
7、缓存的雪崩以及穿透的理解？
8、HashMap的key可以重复吗？
9、synchronized和lock的区别？
10.开发一个大型网站你会考虑哪些问题? 总结


多线程并发编程总结

分布式锁的实现原理

阻塞IO和非阻塞IO的多路复用问题

mysql binglog的原理和分析

cooker和session的联系和区别

sprint boot的aop 和ioc 最核心的东西解释

java 中的netty原理以及nio


题目：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？
bit-map  (https://www.cnblogs.com/Rosanna/p/3302227.html)   
优点：1.运算效率高，不许进行比较和移位；2.占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M。 缺点：所有的数据不能重复。即不可对重复的数据进行排序和查找(http://blog.csdn.net/wangwei890702/article/details/8195862)




redis 系列：

字符串String、字典Hash、列表List、集合Set、有序集合SortedSet。如果你是Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。如果你说还玩过Redis Module，像BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。（bloom  filter 说明     http://iluoxuan.iteye.com/blog/1718254）

使用过Redis分布式锁么，它是什么回事（https://www.cnblogs.com/linjiqin/p/8003838.html）

乐观锁以及悲观锁

假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
使用keys指令可以扫出指定模式的key列表。对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？
答案：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。
如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。
如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。
如果对方追问redis如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。

如果有大量的key需要设置同一时间过期，一般需要注意什么？
如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。


Redis如何做持久化的？
bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。对方追问bgsave的原理是什么？你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。

Pipeline有什么好处，为什么要用pipeline？
可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。

Redis的同步机制了解么？
Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

是否使用过Redis集群，集群的原理是什么？
Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。


需求背景 最近在做一个排队取号的系统
在用户预约时间到达前XX分钟发短信通知，在用户预约时间结束时要判断用户是否去取号了，不然就记录为爽约，在用户取号后开始，等待XX分钟后要发短信提醒是否需要使用其他渠道办理

java OOM 问题
 本文发现了一类OOM（OutOfMemoryError），这类OOM的特点是崩溃时java堆内存和设备物理内存都充足，探索并解释了这类OOM抛出的原因。关键字:OutOfMemoryError ，OOM，pthread_create failed , Could not allocate JNI Env（https://www.jianshu.com/p/e574f0ffdb42)


一，百度一面

1、给一个函数，返回 0 和 1，概率为 p 和 1-p，请你实现一个函数，使得返回 0 1 概率一样。
2、10 亿个 url，每个 url 大小小于 56B，要求去重，内存 4G。
3、把一个 bst 转化成一个双向链表。
4、http 和 https 区别，https 在请求时额外的过程，https 是如何保证数据安全的；
5、IP 地址子网划分；
6、POST 和 GET 区别；
7、DNS 解析过程；
8、硬链接和软连接区别；
9、kill 用法，某个进程杀不掉的原因（进入内核态，忽略 kill 信号）；
10、linux 用过的命令；
11、系统管理命令（如查看内存使用、网络情况）
12、管道的使用；
13、grep 的使用，一定要掌握，每次都会问在文件中查找；
14、shell 脚本；
15、find 命令；
16、awk 使用

二，百度二面

对照着简历问了些东西。

1、Linux 下的一些指令，$（进程 id），$?（上一条命令退出时状态），怎么查看进程，按照内存大小，CPU 占用排序等等。（大写 M 和大写 P）
2、http 的 get 和 post 方法。
3、介绍下你所了解的 epoll。
4、数据库 sql 的了解程度。
5、项目中遇到的问题，自己咋解决的等等。
6、手写一个全排列。
7、b 树和 b 树。
8、介绍一下 hash，怎么解决冲突。
9、进程间的通信，共享内存方式的优缺点。

三，百度三面

1、说下你平时看的一些技术博客，书籍；
2、linux 下的一些指令；
3、工作中你觉得最不爽的事情是什么；
4、说下你的优缺点；
6、有没有想过去创业公司；
7、写个 strcpy 函数；
8、说说你自己的性格；
9、给你一个系统（面试官好像是无人车部门的），后台的逻辑已经实现了，但是前端加载很慢，怎么检测；
10、以后可能要学习很多新技术，你怎么看；
11、项目中遇到的困难（提前想好，并且把实现或者优化方法说清楚）；
12、系统的量级、pv、uv 等；
13、应对高并发的解决办法（分布式）；
14、在项目中主要负责了哪些工作。
15、nginx 的负载均衡；
16、分布式缓存的一致性，服务器如何扩容（哈希环）


解析：
分析

概率问题，并且让返回值概率一样，但是这个函数的返回值是不一样的P(1)=1-p,P(0)=p; 
P(1)*P(0)=(1-p)*p=p-p^2; P(1)*P(1)=p*p 
P(0)*P(0)=(1-p)(1-p) P(0)*P(1)=p(1-p)=p-p^2 
所以：P(1)P(0)=P(0)P(1)。我们已经构造出这个相等的概率了，我们剩下的就是把这个代码展示在代码上。

public int random(){
    int result;  

    while (true)  
    {  
        int i = RANDOM();  
        int j = RANDOM(); 
         
        if (i == 0 && j == 1)  
        {  
            result = 0;  
            break;  
        }  
        else if (i == 1 && j == 0)  
        {  
            result = 1;  
            break;  
        }  
        else  
            continue;  
    }  

    return result;  
}

给定a、b两个文件，各存放50亿个url，每个url各占用64字节，内存限制是4G，如何找出a、b文件共同的url？ 思路：可以估计每个文件的大小为5G*64=300G，远大于4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。 遍历文件a，对每个url求取hash(url)%1000，然后根据所得值将url分别存储到1000个小文件（设为a0,a1,...a999）当中。这样每个小文件的大小约为300M。遍历文件b，采取和a相同的方法将url分别存储到1000个小文件(b0,b1....b999)中。这样处理后，所有可能相同的url都在对应的小文件(a0 vs b0, a1 vs b1....a999 vs b999)当中，不对应的小文件（比如a0 vs b99）不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。 比如对于a0 vs b0，我们可以遍历a0，将其中的url存储到hash_map当中。然后遍历b0，如果url在hash_map中，则说明此url在a和b中同时存在，保存到文件中即可。 如果分成的小文件不均匀，导致有些小文件太大（比如大于2G），可以考虑将这些太大的小文件再按类似的方法分成小小文件即可




据说有人归纳了计算机的五大常用算法，它们是贪婪算法，动态规划算法，分治算法，回溯算法以及分支限界算法。虽然不知道为何要将这五个算法归为最常用的算法，但是毫无疑问，这五个算法是有很多应用场景的，最优化问题大多可以利用这些算法解决。算法的本质就是解决问题。当数据量比较小时，其实根本就不需要什么算法，写一些for循环完全就可以很快速的搞定了，但是当数据量比较大，场景比较复杂的时候，编写for循环就是一个很不明智的方式了。一是耗时，二是写出的代码绝对是天书。当然还有第三点，这点也是最重要的，写代码是一种艺术，而不是搬砖。前面的文章里对这五种算法都已经做了详细的讲解和归纳，本文主要是一个总结，将这五种算法整理到一起来对比，分析一下。
题目 穷举法简单粗暴，没有什么问题是搞不定的，只要你肯花时间。同时对于小数据量，穷举法就是最优秀的算法。就像太祖长拳，简单，人人都能会，能解决问题，但是与真正的高手过招，就颓了。
1） 贪婪算法 贪婪算法可以获取到问题的局部最优解，不一定能获取到全局最优解，同时获取最优解的好坏要看贪婪策略的选择。特点就是简单，能获取到局部最优解。就像打狗棍法，同一套棍法，洪七公和鲁有脚的水平就差太多了，因此同样是贪婪算法，不同的贪婪策略会导致得到差异非常大的结果。 
具体的详细解析请参见下面的文章： 
http://blog.csdn.net/changyuanchn/article/details/51417211
2） 动态规划算法 当最优化问题具有重复子问题和最优子结构的时候，就是动态规划出场的时候了。动态规划算法的核心就是提供了一个memory来缓存重复子问题的结果，避免了递归的过程中的大量的重复计算。动态规划算法的难点在于怎么将问题转化为能够利用动态规划算法来解决。当重复子问题的数目比较小时，动态规划的效果也会很差。如果问题存在大量的重复子问题的话，那么动态规划对于效率的提高是非常恐怖的。就像斗转星移武功，对手强它也会比较强，对手若，他也会比较弱。 
具体的详细解析请参见下面的文章： 
http://blog.csdn.net/changyuanchn/article/details/51420028 
http://blog.csdn.net/changyuanchn/article/details/51429979
3）分治算法 分治算法的逻辑更简单了，就是一个词，分而治之。分治算法就是把一个大的问题分为若干个子问题，然后在子问题继续向下分，一直到base cases，通过base cases的解决，一步步向上，最终解决最初的大问题。分治算法是递归的典型应用。 
具体的详细解析请参见下面的文章： 
http://blog.csdn.net/changyuanchn/article/details/17150109 
http://blog.csdn.net/changyuanchn/article/details/51465175
4） 回溯算法 回溯算法是深度优先策略的典型应用，回溯算法就是沿着一条路向下走，如果此路不同了，则回溯到上一个 
分岔路，在选一条路走，一直这样递归下去，直到遍历万所有的路径。八皇后问题是回溯算法的一个经典问题，还有一个经典的应用场景就是迷宫问题。 
具体的详细解析请参见下面的文章： 
http://blog.csdn.net/changyuanchn/article/details/17354461
5） 分支限界算法 回溯算法是深度优先，那么分支限界法就是广度优先的一个经典的例子。回溯法一般来说是遍历整个解空间，获取问题的所有解，而分支限界法则是获取一个解（一般来说要获取最优解）。 
具体的详细解析请参见下面的文章： 
http://blog.csdn.net/changyuanchn/article/details/17102037














