

主流的MQ有很多，比如ActiveMQ、RabbitMQ、RocketMQ、Kafka、ZeroMQ等


Apache RocketMQ

RocketMQ(的分布式特性 半保留消息，确认消息，回退)
消息传递6次以后失败，人工介入

RocketMQ目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景
MQ 可应用在多个领域，包括异步通信解耦、企业解决方案、金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、手游、视频、物联网、车联网等。
MQ 可以应用但不局限于以下业务场景：
一对多，多对多异步解耦，基于发布订阅模型，对分布式应用进行异步解耦，增加应用的水平扩展能力。
削峰填谷，大促等流量洪流突然来袭时，MQ 可以缓冲突发流量，避免下游订阅系统因突发流量崩溃。
日志监控，作为重要日志的监控通信管道，将应用日志监控对系统性能影响降到最低。
消息推送，为社交应用和物联网应用提供点对点推送，一对多广播式推送的能力。
金融报文，发送金融报文，实现金融准实时的报文传输，可靠安全。
电信信令，将电信信令封装成消息，传递到各个控制终端，实现准实时控制和信息传递。


数据可靠性
RocketMQ支持异步实时刷盘，同步刷盘，同步复制，异步复制
卡夫卡使用异步刷盘方式，异步复制/同步复制

性能对比
卡夫卡单机写入TPS约在百万条/秒，消息大小10个字节
RocketMQ单机写入TPS单实例约7万条/秒，单机部署3个Broker，可以跑到最高12万条/秒，消息大小10个字节


单机支持的队列数
Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长。Kafka分区数无法过多的问题
RocketMQ单机支持最高5万个队列，负载不会发生明显变化


队列多有什么好处？
单机可以创建更多话题，因为每个主题都是由一批队列组成
消费者的集群规模和队列数成正比，队列越多，消费类集群可以越大

消息投递实时性
Kafka使用短轮询方式，实时性取决于轮询间隔时间，0.8以后版本支持长轮询。
RocketMQ使用长轮询，同Push方式实时性一致，消息的投递延时通常在几个毫秒。

消费失败重试
卡夫卡消费失败不支持重试。
RocketMQ消费失败支持定时重试，每次重试间隔时间顺延

严格的消息顺序
卡夫卡支持消息顺序，但是一台代理宕机后，就会产生消息乱序
RocketMQ支持严格的消息顺序，在顺序消息场景下，一台Broker宕机后，发送消息会失败，但是不会乱序

分布式事务消息
卡夫卡不支持分布式事务消息
阿里云MQ支持分布式事务消息，未来开源版本的RocketMQ也有计划支持分布式事务消息


消息查询
卡夫卡不支持消息查询
RocketMQ支持根据消息标识查询消息，也支持根据消息内容查询消息（发送消息时指定一个消息密钥，任意字符串，例如指定为订单编号）

消息回溯
卡夫卡理论上可以按照偏移来回溯消息
RocketMQ支持按照时间来回溯消息，精度毫秒，例如从一天之前的某时某分某秒开始重新消费消息

消费并行度
Kafka的消费并行度依赖Topic配置的分区数，如分区数为10，那么最多10台机器来并行消费（每台机器只能开启一个线程），或者一台机器消费（10个线程并行消费）。即消费并行度和分区数一致。
RocketMQ消费并行度分两种情况
顺序消费方式并行度同卡夫卡完全一致
乱序方式并行度取决于Consumer的线程数，如Topic配置10个队列，10台机器消费，每台机器100个线程，那么并行度为1000。


消息轨迹
卡夫卡不支持消息轨迹
阿里云MQ支持消息轨迹





kafka日志系统：
但是kafka并不能满足他们的要求，尤其是低延迟和高可靠性
Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache定级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。



RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。









